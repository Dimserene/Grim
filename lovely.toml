[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''chips_text = '0','''
position = 'after'
payload = '''skills = {},
skill_xp = 0,
reset_antes = {},
reset_antes2 = {},
reset_antes3 = {},
ghost_skill_xp = 0,
xp_interest = 1,
xp_interest_rate = 10,
xp_interest_max = 50,
grm_unlocks = {
    shop_rerolls = 0,
},
grim_boss_dollars = 0,
grim_hand_size_bonus = 0,
ante_banners = {},
grim_class = {},
special_levels = {
    heart = 0,
    club = 0,
    spade = 0,
    diamond = 0,
    nothing = 0,
    debuff = 0,
    face_down = 0,
    not_allowed = 0,
    overshoot = 0,
    money = 0,
    grind = 0,
},
stellar_levels = {
    hearts = {chips = 0, mult = 0},
    diamonds = {chips = 0, mult = 0},
    clubs = {chips = 0, mult = 0},
    spades = {chips = 0, mult = 0},
    nothings = {chips = 0, mult = 0},
},
nullified_blinds = {},
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if center.name == "Wee Joker" and (center.discovered or self.bypass_discovery_center) then'''
position = 'before'
payload = '''if center.set == "Skill" then 
    H = W
    self.T.h = H
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''(_c.set == 'Joker' and G.C.RARITY[_c.rarity]) or'''
position = 'after'
payload = '''(_c.set == 'Skill' and G.C.ORANGE) or'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if not self.bypass_lock and self.config.center.unlocked ~= false and'''
position = 'before'
payload = '''if not self.bypass_lock and self.config.center.unlocked ~= false and
    (self.ability.set == 'Skill') and
    not self.config.center.discovered and 
    ((self.area ~= G.jokers and self.area ~= G.consumeables and self.area) or not self.area) then
        card_type = 'Undiscovered'
    end  
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''elseif not self.params.bypass_discovery_center and (_center.set == 'Edition' or _center.set == 'Joker' or _center.consumeable or _center.set == 'Voucher' or _center.set == 'Booster') and not _center.discovered then'''
position = 'before'
payload = '''elseif _center.set == 'Skill' and not _center.unlocked and not self.params.bypass_discovery_center then 
    self.children.center = Sprite(self.T.x, self.T.y, self.T.w, self.T.h, G.ASSET_ATLAS["grm_skills2"], {x = 3, y = 0})
elseif not self.params.bypass_discovery_center and (_center.set == 'Skill') and not _center.discovered then
    self.children.center = Sprite(self.T.x, self.T.y, self.T.w, self.T.h, G.ASSET_ATLAS[SMODS.UndiscoveredSprites["Skill"].atlas], SMODS.UndiscoveredSprites["Skill"].pos)
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = '''total = {tally = 0, of = 0},'''
position = 'before'
payload = '''skills = {tally = 0, of = 0},
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = '''for _, v in pairs(G.P_BLINDS) do'''
position = 'before'
payload = '''if G.P_SKILLS then
    for _, v in pairs(G.P_SKILLS) do
        G.DISCOVER_TALLIES.total.of = G.DISCOVER_TALLIES.total.of+1
        G.DISCOVER_TALLIES.skills.of = G.DISCOVER_TALLIES.skills.of+1
        if v.discovered then 
            G.DISCOVER_TALLIES.total.tally = G.DISCOVER_TALLIES.total.tally+1
            G.DISCOVER_TALLIES.skills.tally = G.DISCOVER_TALLIES.skills.tally+1
        end
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''Stake = {},'''
position = 'after'
payload = '''Skill = {},'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''self.P_LOCKED = {}'''
position = 'after'
payload = '''self.P_SKILLS = {
    sk_grm_chime_1 = {order = 1, key = 'sk_grm_chime_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Chime I", xp_req = 150, pos = {x=1,y=0}, set = "Skill", effect = "", config = {}, prereq = {}},
    sk_grm_chime_2 = {order = 2, key = 'sk_grm_chime_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Chime II", xp_req = 350, pos = {x=2,y=0}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_chime_1'}},
    sk_grm_chime_3 = {order = 3, key = 'sk_grm_chime_3', unlocked = false, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Chime III", xp_req = 800, pos = {x=4,y=0}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_chime_2'}, unlock_condition = {type = 'ante_up', ante = 17}},
    sk_grm_hexahedron_1 = {order = 4, key = 'sk_grm_hexahedron_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Hexahedron I", xp_req = 300, pos = {x=3,y=1}, set = "Skill", effect = "", config = {}, prereq = {}},
    sk_grm_hexahedron_2 = {order = 5, key = 'sk_grm_hexahedron_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Hexahedron II", xp_req = 400, pos = {x=2,y=2}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_hexahedron_1'}},
    sk_grm_hexahedron_3 = {order = 6, key = 'sk_grm_hexahedron_3', unlocked = false, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Hexahedron III", xp_req = 650, pos = {x=0,y=1}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_hexahedron_2'}},
    sk_grm_strike_1 = {order = 7, key = 'sk_grm_strike_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Strike I", xp_req = 200, pos = {x=0,y=2}, set = "Skill", effect = "", config = {}, prereq = {}},
    sk_grm_strike_2 = {order = 8, key = 'sk_grm_strike_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Strike II", xp_req = 500, pos = {x=1,y=2}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_strike_1'}},
    sk_grm_strike_3 = {order = 9, key = 'sk_grm_strike_3', unlocked = false, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Strike III", xp_req = 800, pos = {x=2,y=1}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_strike_2'}},
    sk_grm_ease_1 = {order = 10, key = 'sk_grm_ease_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Ease I", xp_req = 250, pos = {x=3,y=0}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_strike_1'}},
    sk_grm_ease_2 = {order = 11, key = 'sk_grm_ease_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Ease II", xp_req = 400, pos = {x=4,y=0}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_ease_1'}},
    sk_grm_ease_3 = {order = 12, key = 'sk_grm_ease_3', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Ease III", xp_req = 500, pos = {x=4,y=3}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_ease_2'}},
    sk_grm_mystical_1 = {order = 13, key = 'sk_grm_mystical_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Mystical I", xp_req = 300, pos = {x=0,y=1}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_hexahedron_1'}},
    sk_grm_mystical_2 = {order = 14, key = 'sk_grm_mystical_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Mystical II", xp_req = 500, pos = {x=1,y=1}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_mystical_1'}},
    sk_grm_mystical_3 = {order = 15, key = 'sk_grm_mystical_3', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Mystical III", xp_req = 600, pos = {x=2,y=1}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_mystical_2'}},
    sk_grm_ocean_1 = {order = 16, key = 'sk_grm_ocean_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Ocean I", xp_req = 300, pos = {x=4,y=1}, set = "Skill", effect = "", config = {}, prereq = {}},
    sk_grm_ocean_2 = {order = 17, key = 'sk_grm_ocean_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Ocean II", xp_req = 300, pos = {x=3,y=2}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_ocean_1'}},
    sk_grm_ocean_3 = {order = 18, key = 'sk_grm_ocean_3', unlocked = false, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Ocean III", xp_req = 600, pos = {x=1,y=1}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_ocean_2'}},
    sk_grm_stake_1 = {order = 19, key = 'sk_grm_stake_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Stake I", xp_req = 200, pos = {x=4,y=2}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_ocean_1'}},
    sk_grm_stake_2 = {order = 20, key = 'sk_grm_stake_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Stake II", xp_req = 450, pos = {x=0,y=3}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_stake_1'}},
    sk_grm_stake_3 = {order = 21, key = 'sk_grm_stake_3', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Stake III", xp_req = 700, pos = {x=0,y=4}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_stake_2'}},
    sk_grm_skillful_1 = {order = 22, key = 'sk_grm_skillful_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Skillful I", xp_req = 300, pos = {x=1,y=3}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_chime_1'}},
    sk_grm_skillful_2 = {order = 23, key = 'sk_grm_skillful_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Skillful II", xp_req = 600, pos = {x=2,y=3}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_skillful_1'}},
    sk_grm_skillful_3 = {order = 24, key = 'sk_grm_skillful_3', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Skillful III", xp_req = 1000, pos = {x=3,y=3}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_skillful_2'}},
    sk_grm_motley_1 = {order = 25, key = 'sk_grm_motley_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Motley I", xp_req = 400, pos = {x=1,y=4}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_strike_2'}},
    sk_grm_motley_2 = {order = 26, key = 'sk_grm_motley_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Motley II", xp_req = 600, pos = {x=3,y=4}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_motley_1'}},
    sk_grm_motley_3 = {order = 27, key = 'sk_grm_motley_3', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Motley III", xp_req = 800, pos = {x=4,y=4}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_motley_2'}},
    sk_grm_fortunate_1 = {order = 28, key = 'sk_grm_fortunate_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Fortunate I", xp_req = 100, pos = {x=2,y=4}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_mystical_1'}},
    sk_grm_fortunate_2 = {order = 29, key = 'sk_grm_fortunate_2', unlocked = false, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Fortunate II", xp_req = 500, pos = {x=3,y=1}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_fortunate_1'}},
    sk_grm_scarce_1 = {order = 30, key = 'sk_grm_scarce_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Scarce I", xp_req = 800, pos = {x=0,y=5}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_hexahedron_2', 'sk_grm_stake_2'}},
    sk_grm_gravity_1 = {order = 31, key = 'sk_grm_gravity_1', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Gravity I", xp_req = 250, pos = {x=2,y=5}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_strike_2'}},
    sk_grm_gravity_2 = {order = 32, key = 'sk_grm_gravity_2', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Gravity II", xp_req = 500, pos = {x=3,y=5}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_gravity_1'}},
    sk_grm_gravity_3 = {order = 33, key = 'sk_grm_gravity_3', unlocked = true, discovered = false, atlas = 'grm_skills', cost = 8, name = "Gravity III", xp_req = 850, pos = {x=4,y=5}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_gravity_2'}},
    sk_grm_ghost_1 = {order = 34, key = 'sk_grm_ghost_1', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Ghost I", xp_req = 300, pos = {x=0,y=0}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_ocean_2'}},
    sk_grm_ghost_2 = {order = 35, key = 'sk_grm_ghost_2', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Ghost II", xp_req = 400, pos = {x=1,y=0}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_ghost_1'}},
    sk_grm_ghost_3 = {order = 36, key = 'sk_grm_ghost_3', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Ghost III", xp_req = 700, pos = {x=2,y=0}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_ghost_2'}},
    sk_grm_receipt_1 = {order = 37, key = 'sk_grm_receipt_1', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Receipt I", xp_req = 250, pos = {x=4,y=1}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_hexahedron_2'}},
    sk_grm_receipt_2 = {order = 38, key = 'sk_grm_receipt_2', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Receipt II", xp_req = 300, pos = {x=0,y=2}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_receipt_1'}},
    sk_grm_receipt_3 = {order = 39, key = 'sk_grm_receipt_3', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Receipt III", xp_req = 500, pos = {x=1,y=2}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_receipt_2'}},
    sk_grm_dash_1 = {order = 40, key = 'sk_grm_dash_1', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Dash I", xp_req = 250, pos = {x=2,y=2}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_motley_2'}},
    sk_grm_dash_2 = {order = 41, key = 'sk_grm_dash_2', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Dash II", xp_req = 400, pos = {x=3,y=2}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_dash_1'}},
    sk_grm_cl_hoarder = {order = 42, key = 'sk_grm_cl_hoarder', unlocked = false, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Hoarder", xp_req = 0, pos = {x=4,y=2}, set = "Skill", effect = "", config = {}, prereq = {}, class = true},
    sk_grm_cl_astronomer = {order = 43, key = 'sk_grm_cl_astronomer', unlocked = false, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Astronomer", xp_req = 0, pos = {x=0,y=3}, set = "Skill", effect = "", config = {}, prereq = {}, class = true},
    sk_grm_orbit_1 = {order = 44, key = 'sk_grm_orbit_1', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Orbit I", xp_req = 300, pos = {x=1,y=3}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_cl_astronomer'}},
    sk_grm_orbit_2 = {order = 45, key = 'sk_grm_orbit_2', unlocked = true, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Orbit II", xp_req = 500, pos = {x=2,y=3}, set = "Skill", effect = "", config = {}, prereq = {'sk_grm_orbit_1'}},
    sk_grm_cl_alchemist = {order = 46, key = 'sk_grm_cl_alchemist', unlocked = false, discovered = false, atlas = 'grm_skills2', cost = 8, name = "Alchemist", xp_req = 0, pos = {x=4,y=3}, set = "Skill", effect = "", config = {}, prereq = {}, class = true},
}'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''local meta = STR_UNPACK(get_compressed(G.SETTINGS.profile..'/'..'meta.jkr') or 'return {}')'''
position = 'after'
payload = '''for k, v in pairs(G.P_SKILLS) do
    SMODS._save_d_u(v)
    v._discovered_unlocked_overwritten = true
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''table.sort(self.P_CENTER_POOLS["Seal"], function (a, b) return a.order < b.order end)'''
position = 'after'
payload = '''table.sort(self.P_CENTER_POOLS["Skill"], function (a, b) return a.order < b.order end)'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if _center.name == 'Square Joker' and (_center.discovered or self.bypass_discovery_center) then'''
position = 'before'
payload = '''if _center.set == 'Skill' then
    self.children.center.scale.y = self.children.center.scale.x
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''elseif self.config.center.name == "Square Joker" then'''
position = 'before'
payload = '''elseif self.config.center.set == "Skill" then
    H = W 
    self.T.h = H*scale
    self.T.w = W*scale'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''for k, v in pairs(self.P_STAKES) do'''
position = 'before'
payload = '''for k, v in pairs(self.P_SKILLS) do
    v.key = k
    if not v.wip and not v.demo then 
        if TESTHELPER_unlocks then v.discovered = true; v.alerted = true  end --REMOVE THIS
        if not v.unlocked and meta.unlocked[k] then 
            v.unlocked = true
        end
        if not v.discovered and meta.discovered[k] then 
            v.discovered = true
        end
        if v.discovered and meta.alerted[k] then 
            v.alerted = true
        elseif v.discovered then
            v.alerted = false
        end
        table.insert(self.P_CENTER_POOLS['Skill'], v)
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''for k, v in pairs(G.P_CENTERS) do'''
position = 'before'
payload = '''for k, v in pairs(G.P_SKILLS) do
    if not v.demo and not v.wip then 
        v.alerted = true
        v.discovered = true
        v.unlocked = true
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''G.ARGS.save_progress.PROFILE = G.PROFILES[G.SETTINGS.profile]'''
position = 'after'
payload = '''for k, v in pairs(self.P_SKILLS) do
    G.ARGS.save_progress.UDA[k] = (v.unlocked and 'u' or '')..(v.discovered and 'd' or '')..(v.alerted and 'a' or '')
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''elseif _c.set == 'Joker' then'''
position = 'before'
payload = '''elseif _c.set == 'Skill' then
    if _c.name == "Mystical III" then
        info_queue[#info_queue+1] = G.P_CENTERS["c_fool"]
    elseif _c.name == "Stake III" then
        loc_vars = {tonumber(string.format("%.2f", (1.3 ^ (G.GAME.round_resets.ante or 0))))}
    elseif _c.name == "Motley I" then
        info_queue[#info_queue+1] = G.P_CENTERS["m_wild"]
    elseif _c.name == "Motley II" then
        info_queue[#info_queue+1] = G.P_CENTERS["c_lovers"]
    elseif _c.name == "Motley III" then
        info_queue[#info_queue+1] = G.P_CENTERS["m_wild"]
    elseif _c.name == "Fortunate I" then
        info_queue[#info_queue+1] = G.P_CENTERS["c_wheel_of_fortune"]
        info_queue[#info_queue+1] = G.P_CENTERS["e_negative"]
    elseif _c.name == "Fortunate II" then
        info_queue[#info_queue+1] = G.P_CENTERS["c_wheel_of_fortune"]
    elseif _c.name == "Orbit II" then
        if G.P_CENTERS["c_grm_dysnomia"].discovered then
            info_queue[#info_queue+1] = G.P_CENTERS["c_grm_dysnomia"]
        end
        if G.P_CENTERS["c_grm_lp_944_20"].discovered then
            info_queue[#info_queue+1] = G.P_CENTERS["c_grm_lp_944_20"]
        end
    elseif _c.name == "Ghost II" then
        info_queue[#info_queue+1] = G.P_TAGS["tag_ethereal"]
    end
    if card and card.area and card.area.config.skill_table and card.config.center and not G.GAME.skills[card.config.center.key] then
        localize{type = 'descriptions', key = _c.key, set = _c.set, nodes = desc_nodes, vars = loc_vars}
        localize{type = 'descriptions', key = 'unlearned_skill', set = 'Other', nodes = desc_nodes, vars = {number_format(card.config.center.xp_req)}}
    else
        localize{type = 'descriptions', key = _c.key, set = _c.set, nodes = desc_nodes, vars = loc_vars}
    end
    if specific_vars and specific_vars.sticker then info_queue[#info_queue+1] = {key = string.lower(specific_vars.sticker)..'_sticker', set = 'Other'} end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''G.GAME.stake > 1 and {'''
position = 'before'
payload = '''{
    label = localize('b_skills'),
    tab_definition_function = G.UIDEF.learned_skills,
},'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''elseif args.type == 'use' then'''
position = 'before'
payload = '''elseif args.type == 'learn' then 
    button_contents = {n=G.UIT.T, config={text = localize('b_learn'),colour = G.C.WHITE, scale = 0.5}}'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''elseif card.ability.set == 'Voucher' then'''
position = 'before'
payload = '''elseif card.ability.set == 'Skill' then
    learn_skill(card)
    G.GAME.skills[card.key] = true'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''elseif card.area and card.area == G.pack_cards then'''
position = 'before'
payload = '''elseif card and card.area and card.area.config.skill_table then
    return {
      n=G.UIT.ROOT, config = {padding = 0, colour = G.C.CLEAR}, nodes={
        {n=G.UIT.R, config={ref_table = card, r = 0.08, padding = 0.1, align = "bm", minw = 0.5*card.T.w - 0.15, maxw = 0.9*card.T.w - 0.15, minh = 0.3*card.T.h, hover = true, shadow = true, colour = G.C.UI.BACKGROUND_INACTIVE, one_press = true, button = 'learn_skill', func = 'can_learn'}, nodes={
          {n=G.UIT.T, config={text = localize('b_learn'),colour = G.C.UI.TEXT_LIGHT, scale = 0.45, shadow = true}}
        }},
    }}'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''local card_count = self ~= G.shop_vouchers and {n=G.UIT.R, config={align = self == G.jokers and 'cl' or self == G.hand and 'cm' or 'cr', padding = 0.03, no_fill = true}, nodes={'''
position = 'at'
payload = '''local card_count = ((self ~= G.shop_vouchers) and not (self.config.skill_table)) and {n=G.UIT.R, config={align = self == G.jokers and 'cl' or self == G.hand and 'cm' or 'cr', padding = 0.03, no_fill = true}, nodes={'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''self.highlighted = is_higlighted'''
position = 'after'
payload = '''if self.ability.set == "Skill" then
    if self.highlighted and self.area and self.area.config.type ~= 'shop' then
        local x_off = (self.ability.consumeable and -0.1 or 0)
        self.children.use_button = UIBox{
            definition = G.UIDEF.use_and_sell_buttons(self), 
            config = {align=
                    ((self.area == G.jokers) or (self.area == G.consumeables)) and "cr" or
                    "bmi"
                , offset = 
                    ((self.area == G.jokers) or (self.area == G.consumeables)) and {x=x_off - 0.4,y=0} or
                    {x=0,y=0.65},
                parent =self}
        }
    elseif self.children.use_button then
        self.children.use_button:remove()
        self.children.use_button = nil
    end
end
if self.playing_card then
        if self.highlighted and self.area and self.area == G.consumeables then
            local x_off = (self.ability.consumeable and -0.1 or 0)
            self.children.use_button = UIBox{
                definition = G.UIDEF.use_and_sell_buttons(self), 
                config = {align=
                        ((self.area == G.jokers) or (self.area == G.consumeables)) and "cr" or
                        "bmi"
                    , offset = 
                        ((self.area == G.jokers) or (self.area == G.consumeables)) and {x=x_off - 0.4,y=0} or
                        {x=0,y=0.65},
                    parent =self}
            }
        elseif self.highlighted and (self.ability.name == "m_grm_package") and (self.area ~= G.pack_cards) then
            local x_off = (self.ability.consumeable and -0.1 or 0)
            self.children.use_button = UIBox{
                definition = G.UIDEF.use_and_sell_buttons(self), 
                config = {align=
                        ((self.area == G.jokers) or (self.area == G.consumeables)) and "cr" or
                        "bmi"
                    , offset = 
                        ((self.area == G.jokers) or (self.area == G.consumeables)) and {x=x_off - 0.4,y=0} or
                        {x=0,y=0.65},
                    parent =self}
            }
        elseif self.children.use_button then
            self.children.use_button:remove()
            self.children.use_button = nil
        end
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''elseif hide_desc then'''
position = 'at'
payload = '''elseif hide_desc and not ((_c.set == 'Skill') and card and card.area and card.area.config.skill_table and card.config.center and not G.GAME.skills[card.config.center.key]) then'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.RESET_JIGGLES = true'''
position = 'after'
payload = '''
local skill_saved = false
for i, j in pairs(G.GAME.skills) do
    local saved = calculate_skill(i, {end_of_round = true, game_over = game_over})
    if saved then
        skill_saved = true
    end
end
if game_over and skill_saved then
    game_over = false
end
if (G.GAME.special_levels) and (G.GAME.special_levels["money"] > 0) and G.GAME.dollars < G.GAME.grim_boss_dollars then
    ease_dollars(math.ceil(0.1 * G.GAME.special_levels["money"] * (G.GAME.grim_boss_dollars - G.GAME.dollars)))
end
if (G.GAME.blind_on_deck == "Boss") and G.GAME.special_levels and (G.GAME.special_levels["overshoot"] > 0) then
    local big_func = to_big or (function(x) return x end)
    if big_func(math.abs((G.GAME.blind.chips - G.GAME.chips) / G.GAME.blind.chips)) <= big_func(.015 * G.GAME.special_levels["overshoot"]) then
        add_tag(Tag("tag_negative"))
    end
end
if (G.GAME.blind_on_deck == "Boss") and (G.GAME.special_levels) and (G.GAME.special_levels["grind"] > 0) then
    for i = 1, G.GAME.special_levels["grind"] do
        local rng = pseudorandom('grind')
        local reward = ""
        if rng > 0.66 then
            reward = SMODS.create_card {set = "Lunar", no_edition = true}
        elseif rng > 0.33 then
            reward = SMODS.create_card {set = "Stellar", no_edition = true}
        else
            reward = SMODS.create_card {set = "Planet", no_edition = true}
        end
        reward:set_edition('e_negative')
        reward:add_to_deck()
        reward.ability.no_sell_value = true
        reward:set_cost()
        G.consumeables:emplace(reward)
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''G.GAME.pack_choices = self.config.center.config.choose or 1'''
position = 'after'
payload = '''if G.GAME.skills["sk_grm_mystical_1"] and self.ability.name:find('Arcana') then
    G.GAME.pack_choices = G.GAME.pack_choices + 1
end
if G.GAME.skills["sk_grm_ghost_3"] and self.ability.name:find('Spectral') then
    G.GAME.pack_choices = G.GAME.pack_choices + 2
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''local _size = self.ability.extra'''
position = 'after'
payload = '''if G.GAME.skills["sk_grm_mystical_1"] and self.ability.name:find('Arcana') then
    _size = _size + 1
end
if G.GAME.skills["sk_grm_motley_3"] and self.ability.name:find('Arcana') then
    _size = math.max(2, _size - 1)
end
if G.GAME.skills["sk_grm_gravity_1"] and self.ability.name:find('Celestial') then
    _size = _size + 2
end
if G.GAME.skills["sk_grm_ghost_3"] and self.ability.name:find('Spectral') then
    _size = _size + 4
end
if G.GAME.skills["sk_grm_dash_2"] and self.ability.name:find('Standard') then
    _size = _size * 2
end
local lovers_indexes = nil
if G.GAME.skills["sk_grm_motley_2"] and self.ability.name:find('Arcana') then
    lovers_indexes = {math.floor(pseudorandom('motley') * _size) + 1}
    table.insert(lovers_indexes, math.floor(pseudorandom('motley') * (_size - 1)) + 1)
    if lovers_indexes[2] >= lovers_indexes[1] then
        lovers_indexes[2] = lovers_indexes[2] + 1
    end
    if lovers_indexes[2] < lovers_indexes[1] then
        lovers_indexes = {lovers_indexes[2], lovers_indexes[1]}
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if (self.ability.set == 'Planet' or (self.ability.set == 'Booster' and self.ability.name:find('Celestial'))) and #find_joker('Astronomer') > 0 then self.cost = 0 end'''
position = 'after'
payload = '''if G.GAME.skills["sk_grm_mystical_2"] and (self.ability.set == 'Tarot' or (self.ability.set == 'Booster' and self.ability.name:find('Arcana'))) then
    self.cost = 0
end
if self.ability.no_sell_value then
    self.cost = 0
    self.ability.extra_value = 0
end
if G.GAME.skills["sk_grm_receipt_2"] and ((self.ability.set == 'Voucher') or (self.ability.set == 'Booster')) and (self.cost > 0) then
    self.cost = math.max(1, math.floor(self.cost * 0.7))
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''e.config.ref_table:use_consumeable(area)'''
position = 'after'
payload = '''for i, j in pairs(G.GAME.skills) do
    calculate_skill(i, {using_consumeable = true, card = card})
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''mult, hand_chips, modded = G.GAME.blind:modify_hand(G.play.cards, poker_hands, text, mult, hand_chips)'''
position = 'after'
payload = '''mult, hand_chips = mod_mult(mult), mod_chips(hand_chips)
for i, j in pairs(G.GAME.skills) do
    hand_chips, mult, modded = calculate_skill(i, {modify_base = true, chips = hand_chips, mult = mult, scoring_name = text})
    if modded then
        mult, hand_chips = mod_mult(mult), mod_chips(hand_chips)
        update_hand_text({sound = 'chips2'}, {chips = hand_chips, mult = mult})
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''G.CONTROLLER:recall_cardarea_focus('shop_jokers')'''
position = 'after'
payload = '''for i, j in pairs(G.GAME.skills) do
    calculate_skill(i, {reroll_shop = true})
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''inc_career_stat('c_cards_discarded', highlighted_count)'''
position = 'after'
payload = '''for i, j in pairs(G.GAME.skills) do
    calculate_skill(i, {pre_discard = true})
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if self.ability.name == 'Invisible Joker' and (self.config.center.discovered or self.bypass_discovery_center) then'''
position = 'before'
payload = '''if (self.ability.set == 'Skill') and self and self.area and self.area.config.skill_table and self.config.center and not G.GAME.skills[self.config.center.key] then
    if self:should_draw_base_shader() then
        self.children.center:draw_shader('grm_dimmed', nil, self.ARGS.send_to_shader)
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''local x_mult = card:get_chip_x_mult(context)'''
position = 'before'
payload = '''local xp = card:get_chip_xp(context)
if xp > 0 then 
    ret.xp = xp
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''if effects[ii].mult then'''
position = 'before'
payload = '''if effects[ii].xp then 
    if effects[ii].card then juice_card(effects[ii].card) end
    add_skill_xp(effects[ii].xp, scoring_hand[i])
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''local hand_text_set = false'''
position = 'before'
payload = '''for i, j in pairs(G.GAME.skills) do
    calculate_skill(i, {before = true, scoring_name = text})
end
if next(SMODS.find_card("j_grm_showdown")) then
    local card = SMODS.find_card("j_grm_showdown")[1]
    text,disp_text,poker_hands,scoring_hand,non_loc_disp_text = upgrade_poker_hand_showdown(text, scoring_hand, card)
    mult = mod_mult(G.GAME.hands[text].mult)
    hand_chips = mod_chips(G.GAME.hands[text].chips)
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''G.GAME.round_resets.ante = G.GAME.round_resets.ante + mod'''
position = 'after'
payload = '''if not do_skills then
    for i, j in pairs(G.GAME.skills) do
        calculate_skill(i, {ante_mod = true, current_ante = G.GAME.round_resets.ante, old_ante = G.GAME.round_resets.ante - mod})
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''function ease_ante(mod)'''
position = 'at'
payload = '''function ease_ante(mod, do_skills)'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''edition = poll_edition('wheel_of_fortune', nil, true, true)'''
position = 'at'
payload = '''if G.GAME.skills["sk_grm_fortunate_2"] and G.GAME.skills["sk_grm_fortunate_1"] then
    edition = poll_edition('wheel_of_fortune', nil, false, true, {'e_negative', 'e_polychrome', 'e_holo'})
elseif G.GAME.skills["sk_grm_fortunate_2"] then
    edition = poll_edition('wheel_of_fortune', nil, false, true, {'e_polychrome', 'e_holo'})
elseif G.GAME.skills["sk_grm_fortunate_1"] then
    edition = poll_edition('wheel_of_fortune', nil, false, true)
    if edition == 'e_negative' then
        check_for_unlock({type = 'skill_check', fortune_check = true})
    end
else
    edition = poll_edition('wheel_of_fortune', nil, true, true)
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''pack_cards[i] = card'''
position = 'after'
payload = '''::continue::'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''local card = nil'''
position = 'after'
payload = '''if lovers_indexes and (((lovers_indexes[1] == i) and not G.GAME.used_jokers['c_lovers']) or (lovers_indexes[2] == i)) then
    card = create_card("Tarot", G.pack_cards, nil, nil, true, true, 'c_lovers', 'ar1')
    card:start_materialize({G.C.WHITE, G.C.WHITE}, nil, 1.5*G.SETTINGS.GAMESPEED)
    card.T.x = self.T.x + 0
    card.T.y = self.T.y
    pack_cards[i] = card or {}
    goto continue
end
if self.ability.name:find('Celestial') and G.GAME.used_vouchers.v_telescope and (i ~= 1) then
    local rng = pseudorandom('astro')
    if G.GAME.skills["sk_grm_cl_astronomer"] and (rng <= 0.35) then
        card = create_card("Lunar", G.pack_cards, nil, nil, true, true, nil, 'pl1')
        card:start_materialize({G.C.WHITE, G.C.WHITE}, nil, 1.5*G.SETTINGS.GAMESPEED)
        card.T.x = self.T.x + 0
        card.T.y = self.T.y
        pack_cards[i] = card or {}
        goto continue
    elseif G.GAME.skills["sk_grm_cl_astronomer"] and (rng <= 0.59) then
        card = create_card("Stellar", G.pack_cards, nil, nil, true, true, nil, 'pl1')
        card:start_materialize({G.C.WHITE, G.C.WHITE}, nil, 1.5*G.SETTINGS.GAMESPEED)
        card.T.x = self.T.x + 0
        card.T.y = self.T.y
        pack_cards[i] = card or {}
        goto continue
    end
elseif self.ability.name:find('Celestial') then
    local rng = pseudorandom('astro')
    if G.GAME.skills["sk_grm_cl_astronomer"] and (rng <= 0.34) then
        card = create_card("Lunar", G.pack_cards, nil, nil, true, true, nil, 'pl1')
        card:start_materialize({G.C.WHITE, G.C.WHITE}, nil, 1.5*G.SETTINGS.GAMESPEED)
        card.T.x = self.T.x + 0
        card.T.y = self.T.y
        pack_cards[i] = card or {}
        goto continue
    elseif G.GAME.skills["sk_grm_cl_astronomer"] and (rng <= 0.56) then
        card = create_card("Stellar", G.pack_cards, nil, nil, true, true, nil, 'pl1')
        card:start_materialize({G.C.WHITE, G.C.WHITE}, nil, 1.5*G.SETTINGS.GAMESPEED)
        card.T.x = self.T.x + 0
        card.T.y = self.T.y
        pack_cards[i] = card or {}
        goto continue
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if context.scoring_hand[i].ability.name ~= 'Wild Card' and not context.scoring_hand[i].config.center.any_suit then'''
position = 'at'
payload = '''if context.scoring_hand[i].ability.name ~= 'Wild Card' and not context.scoring_hand[i].config.center.any_suit and not (G.GAME.skills["sk_grm_motley_3"] and (context.scoring_hand[i].config.center ~= G.P_CENTERS.c_base)) then'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if context.scoring_hand[i].ability.name == 'Wild Card' or context.scoring_hand[i].config.center.any_suit then'''
position = 'at'
payload = '''if context.scoring_hand[i].ability.name == 'Wild Card' or context.scoring_hand[i].config.center.any_suit or (G.GAME.skills["sk_grm_motley_3"] and (context.scoring_hand[i].config.center ~= G.P_CENTERS.c_base)) then'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if flush_calc then'''
position = 'before'
payload = '''if (G.GAME.skills["sk_grm_motley_3"] and (self.config.center ~= G.P_CENTERS.c_base)) and (not self.debuff or (bypass_debuff and not flush_calc)) then
    return true
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''function create_card_for_shop(area)'''
position = 'after'
payload = '''   if G.GAME.skills["sk_grm_scarce_1"] then
        G.GAME.joker_rate = 0
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'tag.lua'
pattern = '''if not self.triggered and self.config.type == _context.type then'''
position = 'after'
payload = '''   if (_context.type == 'store_joker_create') and G.GAME.skills["sk_grm_scarce_1"] then
        return
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if self.ability.consumeable.hand_type then'''
position = 'before'
payload = '''if self.ability.consumeable.hand_type and G.GAME.skills["sk_grm_gravity_3"] then
    update_hand_text({sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3}, {handname=localize(self.ability.consumeable.hand_type, 'poker_hands'),chips = G.GAME.hands[self.ability.consumeable.hand_type].chips, mult = G.GAME.hands[self.ability.consumeable.hand_type].mult, level=G.GAME.hands[self.ability.consumeable.hand_type].level})
    level_up_hand(used_tarot, self.ability.consumeable.hand_type)
    update_hand_text({sound = 'button', volume = 0.7, pitch = 1.1, delay = 0}, {mult = 0, chips = 0, handname = '', level = ''})
    card_eval_status_text(self, 'jokers', nil, nil, nil, {colour = G.C.FILTER, message = localize('k_again_ex')})
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''add_round_eval_row({name = 'bottom', dollars = dollars})'''
position = 'before'
payload = '''cash_out_xp = 0
if (G.GAME.blind_on_deck == "Boss") then
    local add_skill_table = {1, 50, 90, 120, 150, 180, 220, 250}
    local plus_xp = add_skill_table[G.GAME.stake] or 300
    if G.GAME.modifiers and G.GAME.modifiers.force_stake_xp then
        plus_xp = G.GAME.modifiers.force_stake_xp
    end
    if G.GAME.blind and G.GAME.blind.config.blind.boss.showdown then
        plus_xp = math.floor(plus_xp * 2)
    end
    local stake_name = localize {type = 'name_text', key = G.P_CENTER_POOLS.Stake[G.GAME.stake].key, set = 'Stake'}
    if plus_xp and (plus_xp > 0) then
        add_custom_round_eval_row(stake_name , tostring(get_modded_xp(plus_xp)) .. " XP")
        cash_out_xp = cash_out_xp + get_modded_xp(plus_xp)
    end
end
if G.GAME.skills["sk_grm_skillful_1"] then
    add_custom_round_eval_row("Skillful I" , tostring(get_modded_xp(30)) .. " XP")
    cash_out_xp = cash_out_xp + get_modded_xp(30)
end
for i0 = 1, #G.jokers.cards do
    local ret0 = G.jokers.cards[i0]:calculate_xp_bonus()
    if ret0 then
        local joker_name = localize {type = 'name_text', key = G.jokers.cards[i0].config.center.key, set = 'Joker'}
        G.jokers.cards[i0]:juice_up(0.7, 0.46)
        add_custom_round_eval_row(joker_name , tostring(get_modded_xp(ret0)) .. " XP")
        cash_out_xp = cash_out_xp + get_modded_xp(ret0)
    end
end
if G.GAME.used_vouchers['v_grm_progress'] or G.GAME.used_vouchers['v_grm_complete'] then
    local intrest = math.min(G.GAME.xp_interest_max, math.floor(G.GAME.skill_xp / G.GAME.xp_interest_rate) * G.GAME.xp_interest)
    local intrest_text = " "..localize{type = 'variable', key = 'xp_interest', vars = {G.GAME.xp_interest, G.GAME.xp_interest_rate, G.GAME.xp_interest_max}}
    add_custom_round_eval_row(intrest_text , tostring(get_modded_xp(intrest)) .. " XP", intrest)
    cash_out_xp = cash_out_xp + get_modded_xp(intrest)
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''G.CONTROLLER.locks.toggle_shop = true'''
position = 'after'
payload = '''if G.shop then
    for i, j in pairs(G.GAME.skills) do
        calculate_skill(i, {ending_shop = true})
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''while i <= #G.P_LOCKED do'''
position = 'before'
payload = '''for i, card in pairs(G.P_SKILLS) do
    if not card.unlocked then
        if skill_unlock_check(card, args) then
            unlock_card(card)
        end
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''calculate_reroll_cost(final_free)'''
position = 'after'
payload = '''G.GAME.grm_unlocks.shop_rerolls = G.GAME.grm_unlocks.shop_rerolls + 1
check_for_unlock({type = 'skill_check'})
if G.GAME.skills["sk_grm_hexahedron_3"] then
    local more_reroll = math.floor(old_cost / 11)
    if more_reroll > 0 then
        G.GAME.current_round.free_rerolls = G.GAME.current_round.free_rerolls + more_reroll
        calculate_reroll_cost(true)
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''G.GAME.current_round.discards_left = G.GAME.current_round.discards_left + mod'''
position = 'after'
payload = '''check_for_unlock({type = 'skill_check'})'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''local _c, _atlas = G.P_CENTERS[_achievement],'''
position = 'at'
payload = '''local _c, _atlas = (_type == "Skill") and G.P_SKILLS[_achievement] or G.P_CENTERS[_achievement],'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''_type == 'Voucher' and localize('k_voucher') or'''
position = 'after'
payload = '''_type == 'Skill' and localize('k_skill') or'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''if G.GAME.current_round.reroll_cost > 0 then'''
position = 'before'
payload = '''local old_cost = G.GAME.current_round.reroll_cost'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''ease_dollars(G.GAME.current_round.dollars)'''
position = 'before'
payload = '''if G.GAME.skills["sk_grm_receipt_1"] and (G.GAME.current_round.dollars >= 7) then
    ease_dollars(math.floor(G.GAME.current_round.dollars/7))
end
add_skill_xp(cash_out_xp or 0, nil, nil, true)
cash_out_xp = 0'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''rental = self.ability and self.ability.rental'''
position = 'before'
payload = '''xp = center.config.xp or 0,'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''if not G.GAME.current_round.used_packs[i] then'''
position = 'before'
payload = '''if not G.GAME.current_round.used_packs[i] and G.GAME.skills["sk_grm_dash_1"] and (i == 1) then
    G.GAME.current_round.used_packs[i] = get_pack('shop_pack', 'Standard').key
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''set_deck_win()'''
position = 'after'
payload = '''set_skill_win()'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''deck_usage = {},'''
position = 'after'
payload = '''skill_banners = {},'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''G.shared_stickers[self.sticker]:draw_shader('voucher', nil, self.ARGS.send_to_shader, nil, self.children.center)'''
position = 'at'
payload = '''if not self.no_shader then
    G.shared_stickers[self.sticker]:draw_shader('voucher', nil, self.ARGS.send_to_shader, nil, self.children.center)
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''if context.cardarea == G.play then'''
position = 'before'
payload = '''if (card.area == G.consumeables) and card.playing_card then
    ret.playing_card = true
    local chips = card:get_chip_bonus()
    if chips > 0 then 
        ret.chips = chips
    end

    local mult = card:get_chip_mult()
    if mult > 0 then 
        ret.mult = mult
    end

    local xp = card:get_chip_xp(context)
    if xp > 0 then 
        ret.xp = xp
    end

    local x_mult = card:get_chip_x_mult(context)
    if x_mult > 0 then 
        ret.x_mult = x_mult
    end

    local p_dollars = card:get_p_dollars()
    if p_dollars > 0 then 
        ret.p_dollars = p_dollars
    end

    local edition = card:get_edition(context)
    if edition then 
        ret.edition = edition
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''if card.area and card.area.config.type == 'joker' then'''
position = 'before'
payload = '''if card.area and (card.area == G.consumeables) and card.playing_card then
    use = 
    {n=G.UIT.C, config={align = "cr"}, nodes={
      {n=G.UIT.C, config={ref_table = card, align = "cr",maxw = 1.25, padding = 0.1, r=0.08, minw = 1.25, minh = 1, hover = true, shadow = true, colour = G.C.UI.BACKGROUND_INACTIVE, one_press = true, button = 'grm_discard_card', func = 'grm_can_discard_card'}, nodes={
        {n=G.UIT.B, config = {w=0.1,h=0.6}},
        {n=G.UIT.T, config={text = localize('b_discard'),colour = G.C.UI.TEXT_LIGHT, scale = 0.55, shadow = true}}
      }}
    }}
    sell = 
    {n=G.UIT.C, config={align = "cr"}, nodes={
      {n=G.UIT.C, config={ref_table = card, align = "cr",maxw = 1.25, padding = 0.1, r=0.08, minw = 1.25, minh = 1, hover = true, shadow = true, colour = G.C.UI.BACKGROUND_INACTIVE, one_press = true, button = 'grm_draw_card', func = 'grm_can_draw_card'}, nodes={
        {n=G.UIT.B, config = {w=0.1,h=0.6}},
        {n=G.UIT.T, config={text = localize('b_draw'),colour = G.C.UI.TEXT_LIGHT, scale = 0.55, shadow = true}}
      }}
    }}
    local t = {
      n=G.UIT.ROOT, config = {padding = 0, colour = G.C.CLEAR}, nodes={
        {n=G.UIT.C, config={padding = 0.15, align = 'cl'}, nodes={
          {n=G.UIT.R, config={align = 'cl'}, nodes={
            sell
          }},
          {n=G.UIT.R, config={align = 'cl'}, nodes={
            use
          }},
        }},
    }}
    return t
elseif card.playing_card and (card.ability.name == "m_grm_package") and (card.area ~= G.pack_cards) then
    return {
        n=G.UIT.ROOT, config = {padding = 0, colour = G.C.CLEAR}, nodes={
          {n=G.UIT.R, config={mid = true}, nodes={
          }},
          {n=G.UIT.R, config={ref_table = card, r = 0.08, padding = 0.1, align = "bm", minw = 0.5*card.T.w - 0.15, minh = 0.8*card.T.h, maxw = 0.7*card.T.w - 0.15, hover = true, shadow = true, colour = G.C.UI.BACKGROUND_INACTIVE, one_press = true, button = 'grm_pack_card', func = 'grm_can_pack_card'}, nodes={
            {n=G.UIT.T, config={text = localize('b_pack'),colour = G.C.UI.TEXT_LIGHT, scale = 0.55, shadow = true}}
          }},
      }}
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''--Joker on Joker effects'''
position = 'before'
payload = '''if effects.playing_card then
    local reps = {1}
    local j = 1
    while j <= #reps do
        if reps[j] ~= 1 then card_eval_status_text((reps[j].jokers or reps[j].seals).card, 'jokers', nil, nil, nil, (reps[j].jokers or reps[j].seals)) end

        if reps[j] == 1 then 
            --Check for hand doubling
            --From Red seal
            local eval = eval_card(_card, {end_of_round = true,cardarea = G.consumeables, repetition = true, repetition_only = true})
            if next(eval) then 
                for h = 1, eval.seals.repetitions do
                    reps[#reps+1] = eval
                end
            end

            --from Jokers
            for j=1, #G.jokers.cards do
                --calculate the joker effects
                local eval0 = eval_card(G.jokers.cards[j], {cardarea = G.consumeables, other_card = _card, repetition = true})
                if next(eval0) then 
                    for h = 1, eval0.jokers.repetitions do
                        reps[#reps+1] = eval
                    end
                end
            end
        end
        if effects.chips then 
            juice_card(_card)
            hand_chips = mod_chips(hand_chips + effects.chips)
            update_hand_text({delay = 0}, {chips = hand_chips})
            card_eval_status_text(_card, 'chips', effects.chips, percent)
        end

        if effects.mult then 
            juice_card(_card)
            mult = mod_mult(mult + effects.mult)
            update_hand_text({delay = 0}, {mult = mult})
            card_eval_status_text(_card, 'mult', effects.mult, percent)
        end

        if effects.p_dollars then 
            juice_card(_card)
            ease_dollars(effects.p_dollars)
            card_eval_status_text(_card, 'dollars', effects.p_dollars, percent)
        end

        if effects.dollars then 
            juice_card(_card)
            ease_dollars(effects.dollars)
            card_eval_status_text(_card, 'dollars', effects.dollars, percent)
        end

        if effects.extra then
            juice_card(_card)
            local extras = {mult = false, hand_chips = false}
            if effects.extra.mult_mod then mult =mod_mult( mult + effects.extra.mult_mod);extras.mult = true end
            if effects.extra.chip_mod then hand_chips = mod_chips(hand_chips + effects.extra.chip_mod);extras.hand_chips = true end
            if effects.extra.swap then 
                local old_mult = mult
                mult = mod_mult(hand_chips)
                hand_chips = mod_chips(old_mult)
                extras.hand_chips = true; extras.mult = true
            end
            if effects.extra.func then effects.extra.func() end
            update_hand_text({delay = 0}, {chips = extras.hand_chips and hand_chips, mult = extras.mult and mult})
            card_eval_status_text(_card, 'extra', nil, percent, nil, effects.extra)
        end

        --If x_mult added, do mult add event and mult the mult to the total
        if effects.x_mult then
            juice_card(_card)
            mult = mod_mult(mult*effects.x_mult)
            update_hand_text({delay = 0}, {mult = mult})
            card_eval_status_text(_card, 'x_mult', effects.x_mult, percent)
        end

        --calculate the card edition effects
        if effects.edition then
            juice_card(_card)
            hand_chips = mod_chips(hand_chips + (effects.edition.chip_mod or 0))
            mult = mult + (effects.edition.mult_mod or 0)
            mult = mod_mult(mult*(effects.edition.x_mult_mod or 1))
            update_hand_text({delay = 0}, {
                chips = effects.edition.chip_mod and hand_chips or nil,
                mult = (effects.edition.mult_mod or effects.edition.x_mult_mod) and mult or nil,
            })
            card_eval_status_text(_card, 'extra', nil, percent, nil, {
                message = (effects.edition.chip_mod and localize{type='variable',key='a_chips',vars={effects.edition.chip_mod}}) or
                        (effects.edition.mult_mod and localize{type='variable',key='a_mult',vars={effects.edition.mult_mod}}) or
                        (effects.edition.x_mult_mod and localize{type='variable',key='a_xmult',vars={effects.edition.x_mult_mod}}),
                chip_mod =  effects.edition.chip_mod,
                mult_mod =  effects.edition.mult_mod,
                x_mult_mod =  effects.edition.x_mult_mod,
                colour = G.C.DARK_EDITION,
                edition = true})
        end
        j = j + 1
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''for k, v in ipairs(cards_destroyed) do'''
position = 'before'
payload = '''for i=1, #G.consumeables.cards do
    local destroyed = nil
    local card = G.consumeables.cards[i]
    if card.playing_card and (card.ability.name == 'Glass Card') and not card.debuff and pseudorandom('glass') < G.GAME.probabilities.normal/card.ability.extra then 
        card.shattered = true
        cards_destroyed[#cards_destroyed+1] = card
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''return self.ability.mult'''
position = 'at'
payload = '''return self.ability.mult + (self.ability.perma_bonus_mult or 0)'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''if _c.set == 'Other' then'''
position = 'before'
payload = '''if ((_c.set == 'Enhanced') or (_c.set == 'Default')) then
    if specific_vars and specific_vars.grim_bonus_mult and not specific_vars.bonus_mult then
        localize{type = 'other', key = 'card_extra_mult', nodes = desc_nodes, vars = {specific_vars.grim_bonus_mult}}
    end
    if card then
        for i, j in ipairs({"Hearts", "Diamonds", "Spades", "Clubs"}) do
            if card:is_suit(j) and G.GAME.special_levels and (G.GAME.special_levels[string.sub(j:lower(),1,-2)] > 0) then
                info_queue[#info_queue+1] = {set = 'Other', key = 'star_tooltip', vars = {G.GAME.stellar_levels[j:lower()].chips,G.GAME.stellar_levels[j:lower()].mult}}
            end
        end
        local has_suit = false
        for i, j in pairs(SMODS.Suits) do
            if card:is_suit(j.key) then
                has_suit = true
                break
            end
        end
        if not has_suit and G.GAME.special_levels and (G.GAME.special_levels["nothing"] > 0) then
            info_queue[#info_queue+1] = {set = 'Other', key = 'star_tooltip', vars = {G.GAME.stellar_levels["nothing"].chips,G.GAME.stellar_levels["nothing"].mult}}
        end
        if card.ability and card.ability.grm_status and not card.debuff then
            for i, j in pairs(card.ability.grm_status) do
                info_queue[#info_queue+1] = {set = 'Other', key = i}
            end
        end
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''bonus_chips = (self.ability.bonus + (self.ability.perma_bonus or 0)) > 0 and (self.ability.bonus + (self.ability.perma_bonus or 0)) or nil,'''
position = 'after'
payload = '''grim_bonus_mult = ((self.ability.perma_bonus_mult or 0) > 0) and self.ability.perma_bonus_mult or nil,'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''if context.cardarea == G.hand then'''
position = 'after'
payload = '''   if card.debuff and G.GAME.special_levels and (G.GAME.special_levels["debuff"] > 0) then
        card.ability.perma_bonus_mult = card.ability.perma_bonus_mult or 0
        card.ability.perma_bonus_mult = card.ability.perma_bonus_mult + G.GAME.special_levels["debuff"] * 0.2
        card_eval_status_text(card, 'jokers', nil, nil, nil, {colour = G.C.FILTER, message = localize{type='variable',key='a_mult',vars={G.GAME.special_levels["debuff"] * 0.2}}})
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''scoring_hand[i].lucky_trigger = nil'''
position = 'after'
payload = '''   if scoring_hand[i].grim_facing_down and G.GAME.special_levels and (G.GAME.special_levels["face_down"] > 0) then
        effects[#effects + 1] = {x_mult = 1 + (G.GAME.special_levels["face_down"] * 0.05)}
    end
    if scoring_hand[i]:is_suit("Hearts") and G.GAME.special_levels and (G.GAME.special_levels["heart"] > 0) then
        effects[#effects + 1] = {chips = G.GAME.stellar_levels["hearts"].chips, mult = G.GAME.stellar_levels["hearts"].mult}
    end
    if scoring_hand[i]:is_suit("Diamonds") and G.GAME.special_levels and (G.GAME.special_levels["diamond"] > 0) then
        effects[#effects + 1] = {chips = G.GAME.stellar_levels["diamonds"].chips, mult = G.GAME.stellar_levels["diamonds"].mult}
    end
    if scoring_hand[i]:is_suit("Spades") and G.GAME.special_levels and (G.GAME.special_levels["spade"] > 0) then
        effects[#effects + 1] = {chips = G.GAME.stellar_levels["spades"].chips, mult = G.GAME.stellar_levels["spades"].mult}
    end
    if scoring_hand[i]:is_suit("Clubs") and G.GAME.special_levels and (G.GAME.special_levels["club"] > 0) then
        effects[#effects + 1] = {chips = G.GAME.stellar_levels["clubs"].chips, mult = G.GAME.stellar_levels["clubs"].mult}
    end
    local has_suit = false
    for i0, j in pairs(SMODS.Suits) do
        if scoring_hand[i]:is_suit(j.key) then
            has_suit = true
            break
        end
    end
    if not has_suit and G.GAME.special_levels and (G.GAME.special_levels["nothing"] > 0) then
        effects[#effects + 1] = {chips = G.GAME.stellar_levels["nothing"].chips, mult = G.GAME.stellar_levels["nothing"].mult}
    end
    if scoring_hand[i].ability and scoring_hand[i].ability.grm_status and scoring_hand[i].ability.grm_status.rocky and not scoring_hand[i].debuff then
        effects[#effects + 1] = {extra = { func = function()
            for i, j in ipairs(scoring_hand) do
                j.ability.perma_bonus = j.ability.perma_bonus or 0
                j.ability.perma_bonus = j.ability.perma_bonus + 3
                card_eval_status_text(j, 'jokers', nil, nil, nil, {colour = G.C.FILTER, message = localize('k_upgrade_ex')})
            end
        end}}
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.GAME.round_scores.cards_played.amt = G.GAME.round_scores.cards_played.amt + 1'''
position = 'after'
payload = '''if G.hand.highlighted[i].facing == 'back' then G.hand.highlighted[i].grim_facing_down = true end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''check_for_unlock({type = 'play_all_hearts'})'''
position = 'after'
payload = '''for i = 1, #G.play.cards do
    G.play.cards[i].grim_facing_down = nil
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''play_area_status_text("Not Allowed!")--localize('k_not_allowed_ex'), true)'''
position = 'after'
payload = '''if G.GAME.special_levels and (G.GAME.special_levels["not_allowed"] > 0) then
    if pseudorandom('rhea') < G.GAME.probabilities.normal * ((G.GAME.special_levels["not_allowed"] + 1) % 5) / 5 then
        level_up_hand(used_tarot, text, nil, math.ceil((G.GAME.special_levels["not_allowed"] + 1) / 5))
    elseif G.GAME.special_levels["not_allowed"] >= 4 then
        level_up_hand(used_tarot, text, nil, math.floor((G.GAME.special_levels["not_allowed"] + 1) / 5))
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.GAME.blind:set_blind(G.GAME.round_resets.blind)'''
position = 'after'
payload = '''G.E_MANAGER:add_event(Event({trigger = 'immediate',func = function()
    if G.GAME.nullified_blinds[G.GAME.blind.config.blind.key] then G.GAME.blind:disable() end
    return true
end}))'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''{n=G.UIT.R, config={align = "cm",r = 0.1, padding = 0.05, minw = 3.1, colour = G.C.BLACK, emboss = 0.05}, nodes={'''
position = 'after'
payload = '''  ((type == "Boss") and G.GAME.nullified_blinds[G.GAME.round_resets.blind_choices["Boss"]]) and {n=G.UIT.R, config={align = "cm", maxw = 3}, nodes={
      {n=G.UIT.T, config={text = localize('nullified'), scale = 0.3, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.WHITE, shadow = not disabled}}
  }} or {n=G.UIT.R, config={align = "cm", maxw = 3}, nodes={}},'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.GAME.round_bonus.discards = 0'''
position = 'after'
payload = '''G.GAME.grim_boss_dollars = G.GAME.dollars'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''elseif self.sprite_facing == 'back' then'''
position = 'before'
payload = '''if self.ability and (self.ability.grm_status) then
    if self.ability.grm_status.flint then
        G.shared_stickers['sa_flint'].role.draw_major = self
        G.shared_stickers['sa_flint']:draw_shader('dissolve', nil, nil, nil, self.children.center)
    end
    if self.ability.grm_status.subzero then
        G.shared_stickers['sa_subzero'].role.draw_major = self
        G.shared_stickers['sa_subzero']:draw_shader('dissolve', nil, nil, nil, self.children.center)
    end
    if self.ability.grm_status.rocky then
        G.shared_stickers['sa_rocky'].role.draw_major = self
        G.shared_stickers['sa_rocky']:draw_shader('dissolve', nil, nil, nil, self.children.center)
    end
    if self.ability.grm_status.gust then
        self.children.center:draw_shader('voucher', nil, self.ARGS.send_to_shader)
    end
    if self.ability.grm_status.aether then
        G.shared_stickers['sa_aether'].role.draw_major = self
        G.shared_stickers['sa_aether']:draw_shader('dissolve', nil, nil, nil, self.children.center)
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''local text,disp_text,poker_hands,scoring_hand,non_loc_disp_text = G.FUNCS.get_poker_hand_info(G.play.cards)'''
position = 'before'
payload = '''
local destroyed_cards = {}
for i = 1, #G.play.cards do
    local card = G.play.cards[i]
    if card.ability and card.ability.grm_status and card.ability.grm_status.flint and not card.debuff then
        local pool = {}
        for j = 1, #G.play.cards do
            local card2 = G.play.cards[j]
            if not card2.getting_sliced and (card2 ~= card) then
                table.insert(pool, card2)
            end
        end
        if #pool > 0 then
            local target = pseudorandom_element(pool, pseudoseed('grm_flint'))
            target.getting_sliced = true
            table.insert(destroyed_cards, {card, target})
        end
    end
    if card.ability and card.ability.grm_status and card.ability.grm_status.subzero and not card.debuff then
        G.GAME.grim_hand_size_bonus = (G.GAME.grim_hand_size_bonus or 0) + 1
    end
end
for i, j in ipairs(destroyed_cards) do
    j[1].ability.perma_bonus_mult = j[1].ability.perma_bonus_mult or 0
    j[1].ability.perma_bonus_mult = j[1].ability.perma_bonus_mult + 1
    card_eval_status_text(j[1], 'jokers', nil, nil, nil, {colour = G.C.FILTER, message = localize{type='variable',key='a_mult',vars={1}}})
end
for i, j in ipairs(destroyed_cards) do
    j[2]:juice_up(0.8, 0.8)
    j[2]:start_dissolve({G.C.RED}, nil, 1.6)
    if j[2].area then j[2].area:remove_card(j[2]) end
end
for i = 1, #G.hand.cards do
    local card = G.hand.cards[i]
    if card.ability and card.ability.grm_status and card.ability.grm_status.rocky and not card.debuff then
        card.ability.grm_status.rocky = nil
        card_eval_status_text(card, 'jokers', nil, nil, nil, {colour = G.C.FILTER, message = localize('k_ex_expired')})
    end
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''card.T.x = self.T.x'''
position = 'before'
payload = '''if G.GAME.skills["sk_grm_cl_alchemist"] and self.ability.name:find('Standard') then
    card.ability.grm_status = {}
    if pseudorandom('status') < 0.4 then
        card.ability.grm_status.flint = true
    end
    if pseudorandom('status') < 0.4 then
        card.ability.grm_status.subzero = true
    end 
    if pseudorandom('status') < 0.4 then
        card.ability.grm_status.rocky = true
    end 
    if pseudorandom('status') < 0.4 then
        card.ability.grm_status.gust = true
    end 
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''if G.GAME.blind.name == 'The Serpent' and'''
position = 'before'
payload = '''if G.GAME.grim_hand_size_bonus then
    hand_space = hand_space + G.GAME.grim_hand_size_bonus
    G.GAME.grim_hand_size_bonus = 0
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''if destroyed_cards[1] then'''
position = 'before'
payload = '''for i = 1, #G.hand.highlighted do
    if G.hand.highlighted[i].ability and G.hand.highlighted[i].ability.grm_status and G.hand.highlighted[i].ability.grm_status.flint and not G.hand.highlighted[i].debuff then
        G.hand.highlighted[i].ability.grm_status.flint = nil
        card_eval_status_text(G.hand.highlighted[i], 'jokers', nil, nil, nil, {colour = G.C.FILTER, message = localize('k_ex_expired')})
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''table.sort(scoring_hand, function (a, b) return a.T.x < b.T.x end )'''
position = 'before'
payload = '''
for i = 1, #scoring_hand do
    if scoring_hand[i].ability and scoring_hand[i].ability.grm_status and scoring_hand[i].ability.grm_status.subzero and not scoring_hand[i].debuff then
        scoring_hand[i].ability.grm_status.subzero = nil
        card_eval_status_text(scoring_hand[i], 'jokers', nil, nil, nil, {colour = G.C.FILTER, message = localize('k_ex_expired')})
    end
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''function Card:highlight(is_higlighted)'''
position = 'after'
payload = '''   if (self.highlighted ~= is_higlighted) and (self.area == G.hand) and self.ability and self.ability.grm_status and self.ability.grm_status.gust then
        if is_higlighted then
            G.hand.config.highlighted_limit = G.hand.config.highlighted_limit + 1
        else
            G.hand.config.highlighted_limit = G.hand.config.highlighted_limit - 1
        end
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if self.ability and self.ability.perma_debuff then self.debuff = true end'''
position = 'after'
payload = '''   if (self.area == G.hand) and self.debuff and self.ability and self.ability.grm_status and self.ability.grm_status.gust then
        if self.highlighted then
            G.hand.config.highlighted_limit = G.hand.config.highlighted_limit - 1
        end
        self.ability.grm_status.gust = nil
        card_eval_status_text(self, 'jokers', nil, nil, nil, {colour = G.C.FILTER, message = localize('k_ex_expired')})
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''function Card:set_card_area(area)'''
position = 'after'
payload = '''   if self.highlighted and (self.area == G.hand) and (area ~= G.hand) and self.ability and self.ability.grm_status and self.ability.grm_status.gust then
        G.hand.config.highlighted_limit = G.hand.config.highlighted_limit - 1
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''function Card:remove_from_area()'''
position = 'after'
payload = '''   if self.highlighted and (self.area == G.hand) and self.ability and self.ability.grm_status and self.ability.grm_status.gust then
        G.hand.config.highlighted_limit = G.hand.config.highlighted_limit - 1
    end'''
match_indent = true